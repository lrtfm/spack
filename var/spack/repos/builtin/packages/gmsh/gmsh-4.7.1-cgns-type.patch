From edf973c92d574ac91cb31e6a933be38113b8f78d Mon Sep 17 00:00:00 2001
From: Zongze Yang <yangzongze@gmail.com>
Date: Fri, 11 Dec 2020 15:06:17 +0800
Subject: [PATCH 1/3] bugfix-cgns-type

---
 Geo/CGNSConventions.cpp  | 220 +++++++++++++++++++--------------------
 Geo/CGNSConventions.h    |   4 +-
 Geo/CGNSRead.cpp         |  28 ++---
 Geo/CGNSWrite.cpp        |  32 +++---
 Geo/CGNSWriteStruct.cpp  |  16 +--
 Geo/CGNSZone.cpp         |  48 ++++-----
 Geo/CGNSZone.h           |   6 +-
 Geo/CGNSZoneStruct.cpp   |   2 +-
 Geo/CGNSZoneUnstruct.cpp |  18 ++--
 Geo/Homology.h           |   2 +-
 10 files changed, 188 insertions(+), 188 deletions(-)

diff --git a/Geo/CGNSConventions.cpp b/Geo/CGNSConventions.cpp
index 3f9378d..ef28d12 100644
--- a/Geo/CGNSConventions.cpp
+++ b/Geo/CGNSConventions.cpp
@@ -465,71 +465,71 @@ namespace {
   // ------------- Conversion of element types between CGNS and Gmsh
   // -------------
 
-  std::vector<ElementType_t> msh2CgnsEltTypeInit()
+  std::vector<CGNS_ENUMT( ElementType_t )> msh2CgnsEltTypeInit()
   {
-    std::vector<ElementType_t> cgnsType(MSH_MAX_NUM + 1, ElementTypeNull);
+    std::vector<CGNS_ENUMT( ElementType_t )> cgnsType(MSH_MAX_NUM + 1, CGNS_ENUMV( ElementTypeNull ));
 
     // All orders
-    cgnsType[MSH_PNT] = NODE;
+    cgnsType[MSH_PNT] = CGNS_ENUMV( NODE );
 
     // Linear elements
-    cgnsType[MSH_LIN_2] = BAR_2;
-    cgnsType[MSH_TRI_3] = TRI_3;
-    cgnsType[MSH_QUA_4] = QUAD_4;
-    cgnsType[MSH_TET_4] = TETRA_4;
-    cgnsType[MSH_PYR_5] = PYRA_5;
-    cgnsType[MSH_PRI_6] = PENTA_6;
-    cgnsType[MSH_HEX_8] = HEXA_8;
+    cgnsType[MSH_LIN_2] = CGNS_ENUMV( BAR_2 );
+    cgnsType[MSH_TRI_3] = CGNS_ENUMV( TRI_3 );
+    cgnsType[MSH_QUA_4] = CGNS_ENUMV( QUAD_4 );
+    cgnsType[MSH_TET_4] = CGNS_ENUMV( TETRA_4 );
+    cgnsType[MSH_PYR_5] = CGNS_ENUMV( PYRA_5 );
+    cgnsType[MSH_PRI_6] = CGNS_ENUMV( PENTA_6 );
+    cgnsType[MSH_HEX_8] = CGNS_ENUMV( HEXA_8 );
 
     // Quadratic elements
-    cgnsType[MSH_LIN_3] = BAR_3;
-    cgnsType[MSH_TRI_6] = TRI_6;
-    cgnsType[MSH_QUA_8] = QUAD_8;
-    cgnsType[MSH_QUA_9] = QUAD_9;
-    cgnsType[MSH_TET_10] = TETRA_10;
-    cgnsType[MSH_PYR_13] = PYRA_13;
-    cgnsType[MSH_PYR_14] = PYRA_14;
-    cgnsType[MSH_PRI_15] = PENTA_15;
-    cgnsType[MSH_PRI_18] = PENTA_18;
-    cgnsType[MSH_HEX_20] = HEXA_20;
-    cgnsType[MSH_HEX_27] = HEXA_27;
+    cgnsType[MSH_LIN_3] = CGNS_ENUMV( BAR_3 );
+    cgnsType[MSH_TRI_6] = CGNS_ENUMV( TRI_6 );
+    cgnsType[MSH_QUA_8] = CGNS_ENUMV( QUAD_8 );
+    cgnsType[MSH_QUA_9] = CGNS_ENUMV( QUAD_9 );
+    cgnsType[MSH_TET_10] = CGNS_ENUMV( TETRA_10 );
+    cgnsType[MSH_PYR_13] = CGNS_ENUMV( PYRA_13 );
+    cgnsType[MSH_PYR_14] = CGNS_ENUMV( PYRA_14 );
+    cgnsType[MSH_PRI_15] = CGNS_ENUMV( PENTA_15 );
+    cgnsType[MSH_PRI_18] = CGNS_ENUMV( PENTA_18 );
+    cgnsType[MSH_HEX_20] = CGNS_ENUMV( HEXA_20 );
+    cgnsType[MSH_HEX_27] = CGNS_ENUMV( HEXA_27 );
 
     // Cubic elements
-    cgnsType[MSH_LIN_4] = BAR_4;
-    cgnsType[MSH_TRI_9] = TRI_9;
-    cgnsType[MSH_TRI_10] = TRI_10;
-    cgnsType[MSH_QUA_12] = QUAD_12;
-    cgnsType[MSH_QUA_16] = QUAD_16;
-    cgnsType[MSH_TET_16] = TETRA_16;
-    cgnsType[MSH_TET_20] = TETRA_20;
-    cgnsType[MSH_PYR_21] = PYRA_21;
-    cgnsType[MSH_PYR_29] = PYRA_29;
-    cgnsType[MSH_PYR_30] = PYRA_30;
-    cgnsType[MSH_PRI_24] = PENTA_24;
-    //  cgnsType[MSH_PRI_38] = PENTA_38;
-    cgnsType[MSH_PRI_40] = PENTA_40;
-    cgnsType[MSH_HEX_32] = HEXA_32;
-    cgnsType[MSH_HEX_56] = HEXA_56;
-    cgnsType[MSH_HEX_64] = HEXA_64;
+    cgnsType[MSH_LIN_4] = CGNS_ENUMV( BAR_4 );
+    cgnsType[MSH_TRI_9] = CGNS_ENUMV( TRI_9 );
+    cgnsType[MSH_TRI_10] = CGNS_ENUMV( TRI_10 );
+    cgnsType[MSH_QUA_12] = CGNS_ENUMV( QUAD_12 );
+    cgnsType[MSH_QUA_16] = CGNS_ENUMV( QUAD_16 );
+    cgnsType[MSH_TET_16] = CGNS_ENUMV( TETRA_16 );
+    cgnsType[MSH_TET_20] = CGNS_ENUMV( TETRA_20 );
+    cgnsType[MSH_PYR_21] = CGNS_ENUMV( PYRA_21 );
+    cgnsType[MSH_PYR_29] = CGNS_ENUMV( PYRA_29 );
+    cgnsType[MSH_PYR_30] = CGNS_ENUMV( PYRA_30 );
+    cgnsType[MSH_PRI_24] = CGNS_ENUMV( PENTA_24 );
+    //  cgnsType[MSH_PRI_38] = CGNS_ENUMV( PENTA_38 );
+    cgnsType[MSH_PRI_40] = CGNS_ENUMV( PENTA_40 );
+    cgnsType[MSH_HEX_32] = CGNS_ENUMV( HEXA_32 );
+    cgnsType[MSH_HEX_56] = CGNS_ENUMV( HEXA_56 );
+    cgnsType[MSH_HEX_64] = CGNS_ENUMV( HEXA_64 );
 
     // Quartic elements
-    cgnsType[MSH_LIN_5] = BAR_5;
-    cgnsType[MSH_TRI_12] = TRI_12;
-    cgnsType[MSH_TRI_15] = TRI_15;
-    cgnsType[MSH_QUA_16] = QUAD_16;
-    cgnsType[MSH_QUA_25] = QUAD_25;
-    cgnsType[MSH_TET_22] = TETRA_22;
-    cgnsType[MSH_TET_34] = TETRA_34;
-    cgnsType[MSH_TET_35] = TETRA_35;
-    cgnsType[MSH_PYR_29] = PYRA_29;
-    //  cgnsType[MSH_PYR_50] = PYRA_50;
-    cgnsType[MSH_PYR_55] = PYRA_55;
-    cgnsType[MSH_PRI_33] = PENTA_33;
-    //  cgnsType[MSH_PRI_66] = PENTA_66;
-    cgnsType[MSH_PRI_75] = PENTA_75;
-    cgnsType[MSH_HEX_44] = HEXA_44;
-    //  cgnsType[MSH_HEX_98] = HEXA_98;
-    cgnsType[MSH_HEX_125] = HEXA_125;
+    cgnsType[MSH_LIN_5] = CGNS_ENUMV( BAR_5 );
+    cgnsType[MSH_TRI_12] = CGNS_ENUMV( TRI_12 );
+    cgnsType[MSH_TRI_15] = CGNS_ENUMV( TRI_15 );
+    cgnsType[MSH_QUA_16] = CGNS_ENUMV( QUAD_16 );
+    cgnsType[MSH_QUA_25] = CGNS_ENUMV( QUAD_25 );
+    cgnsType[MSH_TET_22] = CGNS_ENUMV( TETRA_22 );
+    cgnsType[MSH_TET_34] = CGNS_ENUMV( TETRA_34 );
+    cgnsType[MSH_TET_35] = CGNS_ENUMV( TETRA_35 );
+    cgnsType[MSH_PYR_29] = CGNS_ENUMV( PYRA_29 );
+    //  cgnsType[MSH_PYR_50] = CGNS_ENUMV( PYRA_50 );
+    cgnsType[MSH_PYR_55] = CGNS_ENUMV( PYRA_55 );
+    cgnsType[MSH_PRI_33] = CGNS_ENUMV( PENTA_33 );
+    //  cgnsType[MSH_PRI_66] = CGNS_ENUMV( PENTA_66 );
+    cgnsType[MSH_PRI_75] = CGNS_ENUMV( PENTA_75 );
+    cgnsType[MSH_HEX_44] = CGNS_ENUMV( HEXA_44 );
+    //  cgnsType[MSH_HEX_98] = CGNS_ENUMV( HEXA_98 );
+    cgnsType[MSH_HEX_125] = CGNS_ENUMV( HEXA_125 );
 
     return cgnsType;
   }
@@ -539,66 +539,66 @@ namespace {
     std::vector<int> mshType(NofValidElementTypes, 0);
 
     // All orders
-    mshType[NODE] = MSH_PNT;
+    mshType[CGNS_ENUMV( NODE )] = MSH_PNT;
 
     // Linear elements
-    mshType[BAR_2] = MSH_LIN_2;
-    mshType[TRI_3] = MSH_TRI_3;
-    mshType[QUAD_4] = MSH_QUA_4;
-    mshType[TETRA_4] = MSH_TET_4;
-    mshType[PYRA_5] = MSH_PYR_5;
-    mshType[PENTA_6] = MSH_PRI_6;
-    mshType[HEXA_8] = MSH_HEX_8;
+    mshType[CGNS_ENUMV( BAR_2 )] = MSH_LIN_2;
+    mshType[CGNS_ENUMV( TRI_3 )] = MSH_TRI_3;
+    mshType[CGNS_ENUMV( QUAD_4 )] = MSH_QUA_4;
+    mshType[CGNS_ENUMV( TETRA_4 )] = MSH_TET_4;
+    mshType[CGNS_ENUMV( PYRA_5 )] = MSH_PYR_5;
+    mshType[CGNS_ENUMV( PENTA_6 )] = MSH_PRI_6;
+    mshType[CGNS_ENUMV( HEXA_8 )] = MSH_HEX_8;
 
     // Quadratic elements
-    mshType[BAR_3] = MSH_LIN_3;
-    mshType[TRI_6] = MSH_TRI_6;
-    mshType[QUAD_8] = MSH_QUA_8;
-    mshType[QUAD_9] = MSH_QUA_9;
-    mshType[TETRA_10] = MSH_TET_10;
-    mshType[PYRA_13] = MSH_PYR_13;
-    mshType[PYRA_14] = MSH_PYR_14;
-    mshType[PENTA_15] = MSH_PRI_15;
-    mshType[PENTA_18] = MSH_PRI_18;
-    mshType[HEXA_20] = MSH_HEX_20;
-    mshType[HEXA_27] = MSH_HEX_27;
+    mshType[CGNS_ENUMV( BAR_3 )] = MSH_LIN_3;
+    mshType[CGNS_ENUMV( TRI_6 )] = MSH_TRI_6;
+    mshType[CGNS_ENUMV( QUAD_8 )] = MSH_QUA_8;
+    mshType[CGNS_ENUMV( QUAD_9 )] = MSH_QUA_9;
+    mshType[CGNS_ENUMV( TETRA_10 )] = MSH_TET_10;
+    mshType[CGNS_ENUMV( PYRA_13 )] = MSH_PYR_13;
+    mshType[CGNS_ENUMV( PYRA_14 )] = MSH_PYR_14;
+    mshType[CGNS_ENUMV( PENTA_15 )] = MSH_PRI_15;
+    mshType[CGNS_ENUMV( PENTA_18 )] = MSH_PRI_18;
+    mshType[CGNS_ENUMV( HEXA_20 )] = MSH_HEX_20;
+    mshType[CGNS_ENUMV( HEXA_27 )] = MSH_HEX_27;
 
     // Cubic elements
-    mshType[BAR_4] = MSH_LIN_4;
-    mshType[TRI_9] = MSH_TRI_9;
-    mshType[TRI_10] = MSH_TRI_10;
-    mshType[QUAD_12] = MSH_QUA_12;
-    mshType[QUAD_16] = MSH_QUA_16;
-    mshType[TETRA_16] = MSH_TET_16;
-    mshType[TETRA_20] = MSH_TET_20;
-    mshType[PYRA_21] = MSH_PYR_21;
-    mshType[PYRA_29] = MSH_PYR_29;
-    mshType[PYRA_30] = MSH_PYR_30;
-    mshType[PENTA_24] = MSH_PRI_24;
-    //  mshType[PENTA_38] = MSH_PRI_38;
-    mshType[PENTA_40] = MSH_PRI_40;
-    mshType[HEXA_32] = MSH_HEX_32;
-    mshType[HEXA_56] = MSH_HEX_56;
-    mshType[HEXA_64] = MSH_HEX_64;
+    mshType[CGNS_ENUMV( BAR_4 )] = MSH_LIN_4;
+    mshType[CGNS_ENUMV( TRI_9 )] = MSH_TRI_9;
+    mshType[CGNS_ENUMV( TRI_10 )] = MSH_TRI_10;
+    mshType[CGNS_ENUMV( QUAD_12 )] = MSH_QUA_12;
+    mshType[CGNS_ENUMV( QUAD_16 )] = MSH_QUA_16;
+    mshType[CGNS_ENUMV( TETRA_16 )] = MSH_TET_16;
+    mshType[CGNS_ENUMV( TETRA_20 )] = MSH_TET_20;
+    mshType[CGNS_ENUMV( PYRA_21 )] = MSH_PYR_21;
+    mshType[CGNS_ENUMV( PYRA_29 )] = MSH_PYR_29;
+    mshType[CGNS_ENUMV( PYRA_30 )] = MSH_PYR_30;
+    mshType[CGNS_ENUMV( PENTA_24 )] = MSH_PRI_24;
+    //  mshType[CGNS_ENUMV( PENTA_38 )] = MSH_PRI_38;
+    mshType[CGNS_ENUMV( PENTA_40 )] = MSH_PRI_40;
+    mshType[CGNS_ENUMV( HEXA_32 )] = MSH_HEX_32;
+    mshType[CGNS_ENUMV( HEXA_56 )] = MSH_HEX_56;
+    mshType[CGNS_ENUMV( HEXA_64 )] = MSH_HEX_64;
 
     // Quartic elements
-    mshType[BAR_5] = MSH_LIN_5;
-    mshType[TRI_12] = MSH_TRI_12;
-    mshType[TRI_15] = MSH_TRI_15;
-    mshType[QUAD_16] = MSH_QUA_16;
-    mshType[QUAD_25] = MSH_QUA_25;
-    mshType[TETRA_22] = MSH_TET_22;
-    mshType[TETRA_34] = MSH_TET_34;
-    mshType[TETRA_35] = MSH_TET_35;
-    mshType[PYRA_29] = MSH_PYR_29;
-    //  mshType[PYRA_50] = MSH_PYR_50;
-    mshType[PYRA_55] = MSH_PYR_55;
-    mshType[PENTA_33] = MSH_PRI_33;
-    //  mshType[PENTA_66] = MSH_PRI_66;
-    mshType[PENTA_75] = MSH_PRI_75;
-    mshType[HEXA_44] = MSH_HEX_44;
-    //  mshType[HEXA_98] = MSH_HEX_98;
-    mshType[HEXA_125] = MSH_HEX_125;
+    mshType[CGNS_ENUMV( BAR_5 )] = MSH_LIN_5;
+    mshType[CGNS_ENUMV( TRI_12 )] = MSH_TRI_12;
+    mshType[CGNS_ENUMV( TRI_15 )] = MSH_TRI_15;
+    mshType[CGNS_ENUMV( QUAD_16 )] = MSH_QUA_16;
+    mshType[CGNS_ENUMV( QUAD_25 )] = MSH_QUA_25;
+    mshType[CGNS_ENUMV( TETRA_22 )] = MSH_TET_22;
+    mshType[CGNS_ENUMV( TETRA_34 )] = MSH_TET_34;
+    mshType[CGNS_ENUMV( TETRA_35 )] = MSH_TET_35;
+    mshType[CGNS_ENUMV( PYRA_29 )] = MSH_PYR_29;
+    //  mshType[CGNS_ENUMV( PYRA_50 )] = MSH_PYR_50;
+    mshType[CGNS_ENUMV( PYRA_55 )] = MSH_PYR_55;
+    mshType[CGNS_ENUMV( PENTA_33 )] = MSH_PRI_33;
+    //  mshType[CGNS_ENUMV( PENTA_66 )] = MSH_PRI_66;
+    mshType[CGNS_ENUMV( PENTA_75 )] = MSH_PRI_75;
+    mshType[CGNS_ENUMV( HEXA_44 )] = MSH_HEX_44;
+    //  mshType[CGNS_ENUMV( HEXA_98 )] = MSH_HEX_98;
+    mshType[CGNS_ENUMV( HEXA_125 )] = MSH_HEX_125;
 
     return mshType;
   }
@@ -606,16 +606,16 @@ namespace {
 } // namespace
 
 // msh to CGNS element type
-ElementType_t msh2CgnsEltType(int mshTag)
+CGNS_ENUMT( ElementType_t ) msh2CgnsEltType(int mshTag)
 {
-  static std::vector<ElementType_t> cgnsType = msh2CgnsEltTypeInit();
+  static std::vector<CGNS_ENUMT( ElementType_t )> cgnsType = msh2CgnsEltTypeInit();
 
-  if(mshTag >= static_cast<int>(cgnsType.size())) return ElementTypeNull;
+  if(mshTag >= static_cast<int>(cgnsType.size())) return CGNS_ENUMV( ElementTypeNull );
   return cgnsType[mshTag];
 }
 
 // CGNS to msh element type
-int cgns2MshEltType(ElementType_t cgnsType)
+int cgns2MshEltType(CGNS_ENUMT( ElementType_t ) cgnsType)
 {
   static std::vector<int> mshType = cgns2MshEltTypeInit();
 
diff --git a/Geo/CGNSConventions.h b/Geo/CGNSConventions.h
index 0ba6db7..c996b42 100644
--- a/Geo/CGNSConventions.h
+++ b/Geo/CGNSConventions.h
@@ -19,10 +19,10 @@
 static const std::string::size_type CGNS_MAX_STR_LEN = 33;
 
 // msh to CGNS element type
-ElementType_t msh2CgnsEltType(int mshTag);
+CGNS_ENUMT( ElementType_t ) msh2CgnsEltType(int mshTag);
 
 // CGNS to msh element type
-int cgns2MshEltType(ElementType_t);
+int cgns2MshEltType(CGNS_ENUMT( ElementType_t ));
 
 std::vector<int> &cgns2MshNodeIndex(int mshTag);
 
diff --git a/Geo/CGNSRead.cpp b/Geo/CGNSRead.cpp
index d6e9fd6..1429990 100644
--- a/Geo/CGNSRead.cpp
+++ b/Geo/CGNSRead.cpp
@@ -35,7 +35,7 @@ namespace {
 
     // read element interpolation tranformation info
     char interpName[CGNS_MAX_STR_LEN];
-    ElementType_t cgnsType;
+    CGNS_ENUMT( ElementType_t ) cgnsType;
     cgnsErr = cg_element_interpolation_read(fileIndex, baseIndex, familyIndex,
                                             interpIndex, interpName, &cgnsType);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
@@ -110,11 +110,11 @@ int readScale(int fileIndex, int baseIndex, double &scale)
 
   scale = 1.;
 
-  MassUnits_t mass;
-  LengthUnits_t length;
-  TimeUnits_t time;
-  TemperatureUnits_t temperature;
-  AngleUnits_t angle;
+  CGNS_ENUMT( MassUnits_t ) mass;
+  CGNS_ENUMT( LengthUnits_t ) length;
+  CGNS_ENUMT( TimeUnits_t ) time;
+  CGNS_ENUMT( TemperatureUnits_t ) temperature;
+  CGNS_ENUMT( AngleUnits_t ) angle;
   cgnsErr = cg_goto(fileIndex, baseIndex, "end");
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
   cgnsErr = cg_units_read(&mass, &length, &time, &temperature, &angle);
@@ -126,23 +126,23 @@ int readScale(int fileIndex, int baseIndex, double &scale)
     return cgnsError(__FILE__, __LINE__, fileIndex);
 
   switch(length) {
-  case Centimeter:
+  case CGNS_ENUMV( Centimeter ):
     Msg::Info("Length unit in CGNS file is cm, rescaling");
     scale = 0.01;
     break;
-  case Millimeter:
+  case CGNS_ENUMV( Millimeter ):
     Msg::Info("Length unit in CGNS file is mm, rescaling");
     scale = 0.001;
     break;
-  case Foot:
+  case CGNS_ENUMV( Foot ):
     Msg::Info("Length unit in CGNS file is feet, rescaling");
     scale = 0.3048;
     break;
-  case Inch:
+  case CGNS_ENUMV( Inch ):
     Msg::Info("Length unit in CGNS file is inch, rescaling");
     scale = 0.0254;
     break;
-  case Meter:
+  case CGNS_ENUMV( Meter ):
     Msg::Info("Length unit in CGNS file is meter, not rescaling");
     break;
   case CG_Null:
@@ -211,13 +211,13 @@ int createZones(int fileIndex, int baseIndex, int meshDim,
   cgsize_t startNode = 0;
   for(int iZone = 1; iZone <= nbZone; iZone++) {
     // read zone type
-    ZoneType_t zoneType;
+    CGNS_ENUMT( ZoneType_t ) zoneType;
     cgnsErr = cg_zone_type(fileIndex, baseIndex, iZone, &zoneType);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
 
     // create zone
     int err = 1;
-    if(zoneType == Structured) {
+    if(zoneType == CGNS_ENUMV( Structured )) {
       if(meshDim == 2) {
         allZones[iZone] =
           new CGNSZoneStruct<2>(fileIndex, baseIndex, iZone, meshDim, startNode,
@@ -229,7 +229,7 @@ int createZones(int fileIndex, int baseIndex, int meshDim,
                                 allEltNodeTransfo, err);
       }
     }
-    else if(zoneType == Unstructured) {
+    else if(zoneType == CGNS_ENUMV( Unstructured )) {
       allZones[iZone] =
         new CGNSZoneUnstruct(fileIndex, baseIndex, iZone, meshDim, startNode,
                              allEltNodeTransfo, err);
diff --git a/Geo/CGNSWrite.cpp b/Geo/CGNSWrite.cpp
index b0acd6e..2f74d16 100644
--- a/Geo/CGNSWrite.cpp
+++ b/Geo/CGNSWrite.cpp
@@ -250,7 +250,7 @@ int writeZone(GModel *model, bool saveAll, double scalingFactor, int meshDim,
   std::string modelName = cgnsString(model->getName(), 32 - partSuffix.size());
   zoneName[partition] = modelName + partSuffix;
   cgnsErr = cg_zone_write(cgIndexFile, cgIndexBase, zoneName[partition].c_str(),
-                          cgZoneSize, Unstructured, &cgIndexZone);
+                          cgZoneSize, CGNS_ENUMV( Unstructured ), &cgIndexZone);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
   // write ordinal (zone number) and family name for CPEX0045
@@ -272,13 +272,13 @@ int writeZone(GModel *model, bool saveAll, double scalingFactor, int meshDim,
 
   // write list of coordinates
   int cgIndexCoord = 0;
-  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                            "CoordinateX", &xcoord[0], &cgIndexCoord);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
-  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                            "CoordinateY", &ycoord[0], &cgIndexCoord);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
-  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+  cgnsErr = cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                            "CoordinateZ", &zcoord[0], &cgIndexCoord);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
@@ -311,8 +311,8 @@ int writeZone(GModel *model, bool saveAll, double scalingFactor, int meshDim,
       eleEnd += numEle;
       MElement *me = ge->getMeshElementByType(eleTypes[eleType], 0);
       int mshType = me->getTypeForMSH();
-      ElementType_t cgType = msh2CgnsEltType(mshType);
-      if(cgType == ElementTypeNull) {
+      CGNS_ENUMT( ElementType_t ) cgType = msh2CgnsEltType(mshType);
+      if(cgType == CGNS_ENUMV( ElementTypeNull )) {
         Msg::Error("Unhandled element type in CGNS ouput (%d)", mshType);
         break;
       }
@@ -348,13 +348,13 @@ int writeZone(GModel *model, bool saveAll, double scalingFactor, int meshDim,
     int iZoneBC;
     cgnsErr =
       cg_boco_write(cgIndexFile, cgIndexBase, cgIndexZone, entityName.c_str(),
-                    FamilySpecified, PointRange, 2, eleEntRange, &iZoneBC);
+                    CGNS_ENUMV( FamilySpecified ), CGNS_ENUMV( PointRange ), 2, eleEntRange, &iZoneBC);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
     // GridLocation not clear: can "Vertex" be understood as "point" elements?
-    // const GridLocation_t loc = (entDim == 2) ? FaceCenter :
-    //                            (entDim == 1) ? EdgeCenter :
-    //                            (entDim == 0) ? Vertex : CellCenter;
-    const GridLocation_t loc = CellCenter;
+    // const CGNS_ENUMT( GridLocation_t ) loc = (entDim == 2) ? CGNS_ENUMV( FaceCenter ) :
+    //                            (entDim == 1) ? CGNS_ENUMV( EdgeCenter ) :
+    //                            (entDim == 0) ? Vertex : CGNS_ENUMV( CellCenter );
+    const CGNS_ENUMT( GridLocation_t ) loc = CGNS_ENUMV( CellCenter );
     cgnsErr = cg_boco_gridlocation_write(cgIndexFile, cgIndexBase, cgIndexZone,
                                          iZoneBC, loc);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
@@ -441,8 +441,8 @@ int writePeriodic(const std::vector<GEntity *> &entitiesPer, int cgIndexFile,
     int connIdx;
     cgnsErr = cg_conn_write(
       cgIndexFile, cgIndexBase, slaveZone, interfaceName.c_str(), Vertex,
-      Abutting1to1, PointList, nodes1.size(), nodes1.data(),
-      masterZoneName.c_str(), Unstructured, PointListDonor, DataTypeNull,
+      CGNS_ENUMV( Abutting1to1 ), CGNS_ENUMV( PointList ), nodes1.size(), nodes1.data(),
+      masterZoneName.c_str(), CGNS_ENUMV( Unstructured ), CGNS_ENUMV( PointListDonor ), CGNS_ENUMV( DataTypeNull ),
       nodes2.size(), nodes2.data(), &connIdx);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
     // get parameters from transformation (CGNS transfo = inverse Gmsh transfo)
@@ -569,8 +569,8 @@ int writeInterfaces(const std::vector<GEntity *> &entitiesInterf,
     int dum;
     cgnsErr = cg_conn_write(
       cgIndexFile, cgIndexBase, part1, interfaceName.c_str(), Vertex,
-      Abutting1to1, PointList, nc.first.size(), nc.first.data(),
-      masterZoneName.c_str(), Unstructured, PointListDonor, DataTypeNull,
+      CGNS_ENUMV( Abutting1to1 ), CGNS_ENUMV( PointList ), nc.first.size(), nc.first.data(),
+      masterZoneName.c_str(), CGNS_ENUMV( Unstructured ), CGNS_ENUMV( PointListDonor ), CGNS_ENUMV( DataTypeNull ),
       nc.second.size(), nc.second.data(), &dum);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, cgIndexFile);
   }
@@ -606,7 +606,7 @@ int writeHOPointInfo(const std::set<int> &eleMshTypes, int cgIndexFile,
     msh2CgnsReferenceElement(mshType, mshPts, u, v, w);
 
     // write nodal set
-    ElementType_t cgnsType = msh2CgnsEltType(mshType);
+    CGNS_ENUMT( ElementType_t ) cgnsType = msh2CgnsEltType(mshType);
     std::ostringstream ossInterp;
     ossInterp << "Element_" << cgnsType;
     std::string interpName = ossInterp.str();
diff --git a/Geo/CGNSWriteStruct.cpp b/Geo/CGNSWriteStruct.cpp
index 97b4068..4016dca 100644
--- a/Geo/CGNSWriteStruct.cpp
+++ b/Geo/CGNSWriteStruct.cpp
@@ -25,7 +25,7 @@ static int writeZonesStruct2D(int cgIndexFile, int cgIndexBase,
     cgsize_t cgZoneSize[6] = {imax, jmax, imax - 1, jmax - 1, 0, 0};
     std::string zoneName = cgnsString("Surface_" + std::to_string(gf->tag()));
     if(cg_zone_write(cgIndexFile, cgIndexBase, zoneName.c_str(), cgZoneSize,
-                     Structured, &cgIndexZone) != CG_OK)
+                     CGNS_ENUMV( Structured ), &cgIndexZone) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
     // write grid
@@ -43,7 +43,7 @@ static int writeZonesStruct2D(int cgIndexFile, int cgIndexBase,
         data[cgZoneSize[0] * j + i] = v->x() * scalingFactor;
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateX", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
@@ -54,7 +54,7 @@ static int writeZonesStruct2D(int cgIndexFile, int cgIndexBase,
         data[cgZoneSize[0] * j + i] = v->y() * scalingFactor;
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateY", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
@@ -65,7 +65,7 @@ static int writeZonesStruct2D(int cgIndexFile, int cgIndexBase,
         data[cgZoneSize[0] * j + i] = v->z() * scalingFactor;
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateZ", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
   }
@@ -87,7 +87,7 @@ static int writeZonesStruct3D(int cgIndexFile, int cgIndexBase,
                               0, 0, 0};
     std::string zoneName = cgnsString("Volume_" + std::to_string(gr->tag()));
     if(cg_zone_write(cgIndexFile, cgIndexBase, zoneName.c_str(), cgZoneSize,
-                     Structured, &cgIndexZone) != CG_OK)
+                     CGNS_ENUMV( Structured ), &cgIndexZone) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
     // write grid
@@ -107,7 +107,7 @@ static int writeZonesStruct3D(int cgIndexFile, int cgIndexBase,
         }
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateX", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
@@ -120,7 +120,7 @@ static int writeZonesStruct3D(int cgIndexFile, int cgIndexBase,
         }
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateY", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
 
@@ -133,7 +133,7 @@ static int writeZonesStruct3D(int cgIndexFile, int cgIndexBase,
         }
       }
     }
-    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, RealDouble,
+    if(cg_coord_write(cgIndexFile, cgIndexBase, cgIndexZone, CGNS_ENUMV( RealDouble ),
                       "CoordinateZ", &data[0], &cgIndexCoord) != CG_OK)
       return cgnsError(__FILE__, __LINE__, cgIndexFile);
   }
diff --git a/Geo/CGNSZone.cpp b/Geo/CGNSZone.cpp
index e46192b..d9aaed4 100644
--- a/Geo/CGNSZone.cpp
+++ b/Geo/CGNSZone.cpp
@@ -17,7 +17,7 @@
 
 #if defined(HAVE_LIBCGNS)
 
-CGNSZone::CGNSZone(int fileIndex, int baseIndex, int zoneIndex, ZoneType_t type,
+CGNSZone::CGNSZone(int fileIndex, int baseIndex, int zoneIndex, CGNS_ENUMT( ZoneType_t ) type,
                    int meshDim, cgsize_t startNode,
                    const Family2EltNodeTransfo &allEltNodeTransfo, int &err)
   : fileIndex_(fileIndex), baseIndex_(baseIndex), meshDim_(meshDim),
@@ -59,10 +59,10 @@ int CGNSZone::readBoundaryCondition(int iZoneBC,
 
   // read general information on boundary condition
   char rawBCName[CGNS_MAX_STR_LEN];
-  BCType_t bcType;
-  PointSetType_t ptSetType;
+  CGNS_ENUMT( BCType_t ) bcType;
+  CGNS_ENUMT( PointSetType_t ) ptSetType;
   cgsize_t nbVal, normalSize;
-  DataType_t normalType;
+  CGNS_ENUMT( DataType_t ) normalType;
   int nbDataSet;
   int normalIndex;
   cgnsErr = cg_boco_info(fileIndex(), baseIndex(), index(), iZoneBC, rawBCName,
@@ -89,21 +89,21 @@ int CGNSZone::readBoundaryCondition(int iZoneBC,
   const int indGeom = nameIndex(geomName, allGeomName);
 
   // read location of bnd. condition (type of mesh entity on which it applies)
-  GridLocation_t location;
+  CGNS_ENUMT( GridLocation_t ) location;
   cgnsErr = cg_boco_gridlocation_read(fileIndex(), baseIndex(), index(),
                                       iZoneBC, &location);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex());
 
   // check that boundary condition is imposed on face elements
-  if((type() == Unstructured) && (meshDim() == 2) && (location != CellCenter) &&
-     (location != EdgeCenter)) {
+  if((type() == CGNS_ENUMV( Unstructured )) && (meshDim() == 2) && (location != CGNS_ENUMV( CellCenter )) &&
+     (location != CGNS_ENUMV( EdgeCenter ))) {
     Msg::Warning("Boundary condition %s is specified on %s instead of "
                  "CellCenter/EdgeCenter in a 2D zone, skipping",
                  geomName.c_str(), cg_GridLocationName(location));
     return 1;
   }
-  else if((type() == Unstructured) && (meshDim() == 3) &&
-          (location != CellCenter) && (location != FaceCenter)) {
+  else if((type() == CGNS_ENUMV( Unstructured )) && (meshDim() == 3) &&
+          (location != CGNS_ENUMV( CellCenter )) && (location != CGNS_ENUMV( FaceCenter ))) {
     Msg::Warning("Boundary condition %s is specified on %s instead of "
                  "CellCenter/FaceCenter in a 3D zone, skipping",
                  geomName.c_str(), cg_GridLocationName(location));
@@ -113,10 +113,10 @@ int CGNSZone::readBoundaryCondition(int iZoneBC,
   // read and store elements on which the BC is imposed
   std::vector<cgsize_t> bcElt;
   switch(ptSetType) {
-  case ElementRange:
-  case PointRange: readBoundaryConditionRange(iZoneBC, bcElt); break;
-  case ElementList:
-  case PointList: readBoundaryConditionList(iZoneBC, nbVal, bcElt); break;
+  case CGNS_ENUMV( ElementRange ):
+  case CGNS_ENUMV( PointRange ): readBoundaryConditionRange(iZoneBC, bcElt); break;
+  case CGNS_ENUMV( ElementList ):
+  case CGNS_ENUMV( PointList ): readBoundaryConditionList(iZoneBC, nbVal, bcElt); break;
   default:
     Msg::Error("Wrong point set type %s is for boundary condition %s",
                cg_PointSetTypeName(ptSetType), geomName.c_str());
@@ -155,14 +155,14 @@ int CGNSZone::readVertices(int dim, double scale,
   std::vector<double> xyz[3];
   for(int iXYZ = 0; iXYZ < dim; iXYZ++) {
     char xyzName[CGNS_MAX_STR_LEN];
-    DataType_t dataType;
+    CGNS_ENUMT( DataType_t ) dataType;
     cgnsErr = cg_coord_info(fileIndex(), baseIndex(), index(), iXYZ + 1,
                             &dataType, xyzName);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex());
     const cgsize_t startInd[3] = {1, 1, 1};
     xyz[iXYZ].resize(nbNode());
     cgnsErr = cg_coord_read(fileIndex(), baseIndex(), index(), xyzName,
-                            RealDouble, startInd, size(), xyz[iXYZ].data());
+                            CGNS_ENUMV( RealDouble ), startInd, size(), xyz[iXYZ].data());
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex());
   }
 
@@ -199,12 +199,12 @@ int CGNSZone::readConnectivities(const std::map<std::string, int> &name2Zone,
   for(int iConnect = 1; iConnect <= nbConnect; iConnect++) {
     // read connection info
     char connectName[CGNS_MAX_STR_LEN], donorName[CGNS_MAX_STR_LEN];
-    GridLocation_t location;
-    GridConnectivityType_t connectType;
-    PointSetType_t ptSetType, ptSetTypeDonor;
+    CGNS_ENUMT( GridLocation_t ) location;
+    CGNS_ENUMT( GridConnectivityType_t ) connectType;
+    CGNS_ENUMT( PointSetType_t ) ptSetType, ptSetTypeDonor;
     cgsize_t connectSize, connectSizeDonor;
-    ZoneType_t zoneTypeDonor;
-    DataType_t dataTypeDonor;
+    CGNS_ENUMT( ZoneType_t ) zoneTypeDonor;
+    CGNS_ENUMT( DataType_t ) dataTypeDonor;
     cgnsErr = cg_conn_info(fileIndex(), baseIndex(), index(), iConnect,
                            connectName, &location, &connectType, &ptSetType,
                            &connectSize, donorName, &zoneTypeDonor,
@@ -226,7 +226,7 @@ int CGNSZone::readConnectivities(const std::map<std::string, int> &name2Zone,
     }
 
     // check if connection type is OK
-    if(connectType != Abutting1to1) {
+    if(connectType != CGNS_ENUMV( Abutting1to1 )) {
       Msg::Warning("Non-conformal connection not supported in CGNS reader");
       continue;
     }
@@ -261,11 +261,11 @@ int CGNSZone::readConnectivities(const std::map<std::string, int> &name2Zone,
 
     // get slave and master nodes
     std::vector<cgsize_t> sNode, mNode;
-    if(ptSetType == PointRange)
+    if(ptSetType == CGNS_ENUMV( PointRange ))
       nodeFromRange(slaveData, sNode);
-    else if(ptSetType == PointList)
+    else if(ptSetType == CGNS_ENUMV( PointList ))
       nodeFromList(slaveData, sNode);
-    if(ptSetTypeDonor != PointListDonor) {
+    if(ptSetTypeDonor != CGNS_ENUMV( PointListDonor )) {
       Msg::Error("Only PointListDonor sets are supported for donnor points for "
                  "general connections in CGNS reader");
       return 0;
diff --git a/Geo/CGNSZone.h b/Geo/CGNSZone.h
index 263e8a2..617da99 100644
--- a/Geo/CGNSZone.h
+++ b/Geo/CGNSZone.h
@@ -24,14 +24,14 @@ class MElement;
 class CGNSZone {
 public:
   CGNSZone() {}
-  CGNSZone(int fileIndex, int baseIndex, int zoneIndex, ZoneType_t type,
+  CGNSZone(int fileIndex, int baseIndex, int zoneIndex, CGNS_ENUMT( ZoneType_t ) type,
            int meshDim, cgsize_t startNode,
            const Family2EltNodeTransfo &allEltNodeTransfo, int &err);
   virtual ~CGNSZone() {}
 
   int index() const { return zoneIndex_; }
   std::string name() const { return name_; }
-  ZoneType_t type() const { return type_; }
+  CGNS_ENUMT( ZoneType_t ) type() const { return type_; }
   cgsize_t startNode() const { return startNode_; }
   cgsize_t nbNode() const { return nbNode_; }
   cgsize_t nbElt() const { return nbElt_; }
@@ -107,7 +107,7 @@ protected:
   int fileIndex_, baseIndex_, meshDim_, zoneIndex_;
   std::string name_;
   cgsize_t size_[9];
-  ZoneType_t type_;
+  CGNS_ENUMT( ZoneType_t ) type_;
   cgsize_t startNode_, nbNode_, nbElt_;
 
   // BC information
diff --git a/Geo/CGNSZoneStruct.cpp b/Geo/CGNSZoneStruct.cpp
index 10dadc2..24e0ba8 100644
--- a/Geo/CGNSZoneStruct.cpp
+++ b/Geo/CGNSZoneStruct.cpp
@@ -351,7 +351,7 @@ template <int DIM>
 CGNSZoneStruct<DIM>::CGNSZoneStruct(
   int fileIndex, int baseIndex, int zoneIndex, int meshDim, cgsize_t startNode,
   const Family2EltNodeTransfo &allEltNodeTransfo, int &err)
-  : CGNSZone(fileIndex, baseIndex, zoneIndex, Structured, meshDim, startNode,
+  : CGNSZone(fileIndex, baseIndex, zoneIndex, CGNS_ENUMV( Structured ), meshDim, startNode,
              allEltNodeTransfo, err)
 {
   // Check consistency
diff --git a/Geo/CGNSZoneUnstruct.cpp b/Geo/CGNSZoneUnstruct.cpp
index d496553..8cd2cc1 100644
--- a/Geo/CGNSZoneUnstruct.cpp
+++ b/Geo/CGNSZoneUnstruct.cpp
@@ -17,7 +17,7 @@
 
 namespace {
 
-  MElement *createElement(ElementType_t sectEltType, std::size_t vertShift,
+  MElement *createElement(CGNS_ENUMT( ElementType_t ) sectEltType, std::size_t vertShift,
                           int entity, const std::vector<MVertex *> &allVert,
                           std::map<int, std::vector<MElement *> > *allElt,
                           const std::vector<cgsize_t> &sectData,
@@ -26,9 +26,9 @@ namespace {
                           std::size_t &iSectData)
   {
     // get element type
-    ElementType_t eltType;
-    if(sectEltType == MIXED) {
-      eltType = static_cast<ElementType_t>(sectData[iSectData]);
+    CGNS_ENUMT( ElementType_t ) eltType;
+    if(sectEltType == CGNS_ENUMV( MIXED )) {
+      eltType = static_cast<CGNS_ENUMT( ElementType_t )>(sectData[iSectData]);
       iSectData++;
     }
     else
@@ -82,7 +82,7 @@ namespace {
 CGNSZoneUnstruct::CGNSZoneUnstruct(
   int fileIndex, int baseIndex, int zoneIndex, int meshDim, cgsize_t startNode,
   const Family2EltNodeTransfo &allEltNodeTransfo, int &err)
-  : CGNSZone(fileIndex, baseIndex, zoneIndex, Unstructured, meshDim, startNode,
+  : CGNSZone(fileIndex, baseIndex, zoneIndex, CGNS_ENUMV( Unstructured ), meshDim, startNode,
              allEltNodeTransfo, err)
 {
   if(err == 0) return;
@@ -104,7 +104,7 @@ int CGNSZoneUnstruct::readSection(
 
   // read section information
   char sectName[CGNS_MAX_STR_LEN];
-  ElementType_t sectEltType;
+  CGNS_ENUMT( ElementType_t ) sectEltType;
   cgsize_t startElt, endElt;
   int nbBnd, parentFlag;
   cgnsErr =
@@ -112,9 +112,9 @@ int CGNSZoneUnstruct::readSection(
                     &sectEltType, &startElt, &endElt, &nbBnd, &parentFlag);
   if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex());
 
-    // check for compatibility with MIXED element sections
+    // check for compatibility with CGNS_ENUMV( MIXED ) element sections
 #if CGNS_VERSION < 4000
-  if(sectEltType == MIXED) {
+  if(sectEltType == CGNS_ENUMV( MIXED )) {
     Msg::Error("Reading MIXED element sections requires CGNS library version"
                "4 or superior");
     return 0;
@@ -129,7 +129,7 @@ int CGNSZoneUnstruct::readSection(
 
   // read connectivity data
   std::vector<cgsize_t> sectData(dataSize), offsetData(endElt - startElt + 2);
-  if(sectEltType == MIXED) {
+  if(sectEltType == CGNS_ENUMV( MIXED )) {
 #if CGNS_VERSION >= 4000
     cgnsErr = cg_poly_elements_read(fileIndex(), baseIndex(), index(), iSect,
                                     sectData.data(), offsetData.data(), 0);
diff --git a/Geo/Homology.h b/Geo/Homology.h
index d9d7cf6..b04478c 100644
--- a/Geo/Homology.h
+++ b/Geo/Homology.h
@@ -151,7 +151,7 @@ public:
   // get a Betti number
   int betti(int dim);
 
-  // get the Euler characteristic
+  // get the CGNS_ENUMV( Euler ) characteristic
   int eulerCharacteristic();
 
   // write the generators to a file
-- 
2.29.0


From 50e9ecbb23077488e37a4ee46f04864f82581921 Mon Sep 17 00:00:00 2001
From: Zongze Yang <yangzongze@gmail.com>
Date: Fri, 11 Dec 2020 15:16:15 +0800
Subject: [PATCH 2/3] fix cgns types more

---
 Geo/CGNSWrite.cpp | 6 +++---
 Geo/CGNSZone.cpp  | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/Geo/CGNSWrite.cpp b/Geo/CGNSWrite.cpp
index 2f74d16..a66d8ed 100644
--- a/Geo/CGNSWrite.cpp
+++ b/Geo/CGNSWrite.cpp
@@ -353,7 +353,7 @@ int writeZone(GModel *model, bool saveAll, double scalingFactor, int meshDim,
     // GridLocation not clear: can "Vertex" be understood as "point" elements?
     // const CGNS_ENUMT( GridLocation_t ) loc = (entDim == 2) ? CGNS_ENUMV( FaceCenter ) :
     //                            (entDim == 1) ? CGNS_ENUMV( EdgeCenter ) :
-    //                            (entDim == 0) ? Vertex : CGNS_ENUMV( CellCenter );
+    //                            (entDim == 0) ? CGNS_ENUMV( Vertex ) : CGNS_ENUMV( CellCenter );
     const CGNS_ENUMT( GridLocation_t ) loc = CGNS_ENUMV( CellCenter );
     cgnsErr = cg_boco_gridlocation_write(cgIndexFile, cgIndexBase, cgIndexZone,
                                          iZoneBC, loc);
@@ -440,7 +440,7 @@ int writePeriodic(const std::vector<GEntity *> &entitiesPer, int cgIndexFile,
     const std::string interfaceName = cgnsString(ossInt.str());
     int connIdx;
     cgnsErr = cg_conn_write(
-      cgIndexFile, cgIndexBase, slaveZone, interfaceName.c_str(), Vertex,
+      cgIndexFile, cgIndexBase, slaveZone, interfaceName.c_str(), CGNS_ENUMV( Vertex ),
       CGNS_ENUMV( Abutting1to1 ), CGNS_ENUMV( PointList ), nodes1.size(), nodes1.data(),
       masterZoneName.c_str(), CGNS_ENUMV( Unstructured ), CGNS_ENUMV( PointListDonor ), CGNS_ENUMV( DataTypeNull ),
       nodes2.size(), nodes2.data(), &connIdx);
@@ -568,7 +568,7 @@ int writeInterfaces(const std::vector<GEntity *> &entitiesInterf,
     const std::string interfaceName = cgnsString(ossInt.str());
     int dum;
     cgnsErr = cg_conn_write(
-      cgIndexFile, cgIndexBase, part1, interfaceName.c_str(), Vertex,
+      cgIndexFile, cgIndexBase, part1, interfaceName.c_str(), CGNS_ENUMV( Vertex ),
       CGNS_ENUMV( Abutting1to1 ), CGNS_ENUMV( PointList ), nc.first.size(), nc.first.data(),
       masterZoneName.c_str(), CGNS_ENUMV( Unstructured ), CGNS_ENUMV( PointListDonor ), CGNS_ENUMV( DataTypeNull ),
       nc.second.size(), nc.second.data(), &dum);
diff --git a/Geo/CGNSZone.cpp b/Geo/CGNSZone.cpp
index d9aaed4..7a72a01 100644
--- a/Geo/CGNSZone.cpp
+++ b/Geo/CGNSZone.cpp
@@ -230,7 +230,7 @@ int CGNSZone::readConnectivities(const std::map<std::string, int> &name2Zone,
       Msg::Warning("Non-conformal connection not supported in CGNS reader");
       continue;
     }
-    if(location != Vertex) {
+    if(location != CGNS_ENUMV( Vertex )) {
       Msg::Warning("Only vertex connections are supported in CGNS reader");
       continue;
     }
-- 
2.29.0


From 6d5876144d1968ad04d9edd5f79ea8a100e4c0e5 Mon Sep 17 00:00:00 2001
From: Zongze Yang <yangzongze@gmail.com>
Date: Fri, 11 Dec 2020 15:47:07 +0800
Subject: [PATCH 3/3] fix go on

---
 Post/PViewDataGModelIO_CGNS.cpp | 22 +++++++++++-----------
 Post/PViewIO_CGNS.cpp           |  8 ++++----
 2 files changed, 15 insertions(+), 15 deletions(-)

diff --git a/Post/PViewDataGModelIO_CGNS.cpp b/Post/PViewDataGModelIO_CGNS.cpp
index 60126d1..273113a 100644
--- a/Post/PViewDataGModelIO_CGNS.cpp
+++ b/Post/PViewDataGModelIO_CGNS.cpp
@@ -35,9 +35,9 @@ namespace {
 
     // read solution interpolation tranformation info
     char interpName[CGNS_MAX_STR_LEN];
-    ElementType_t cgnsType;
+    CGNS_ENUMT( ElementType_t ) cgnsType;
     int order, orderTime;
-    InterpolationType_t interpType;
+    CGNS_ENUMT( InterpolationType_t ) interpType;
     cgnsErr = cg_solution_interpolation_read(fileIndex, baseIndex, familyIndex,
                                              interpIndex, interpName, &cgnsType,
                                              &order, &orderTime, &interpType);
@@ -315,7 +315,7 @@ namespace {
 
   int getEntInPtSet(int fileIndex, int baseIndex, int zoneIndex,
                     int zoneSolIndex, bool isStructured, int dim,
-                    PointSetType_t ptSetType, cgsize_t ptSetSize,
+                    CGNS_ENUMT( PointSetType_t ) ptSetType, cgsize_t ptSetSize,
                     const cgsize_t *zoneEntSize, cgsize_t *solReadRange,
                     std::vector<cgsize_t> &solEntSet)
   {
@@ -329,7 +329,7 @@ namespace {
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
 
     // get number of values and entities to read in solution
-    if(ptSetType == PointRange) {
+    if(ptSetType == CGNS_ENUMV( PointRange )) {
       if(isStructured) {
         for(int i = 0; i < dim; i++) {
           solReadRange[i] = 1;
@@ -360,7 +360,7 @@ namespace {
         UnstructuredIndexing::entFromRange(ptSet.data(), solEntSet);
       }
     }
-    else if(ptSetType == PointList) {
+    else if(ptSetType == CGNS_ENUMV( PointList )) {
       solReadRange[0] = 1;
       solReadRange[1] = ptSet.size();
       if(isStructured) {
@@ -405,7 +405,7 @@ namespace {
 
     // check FlowSolution name
     char rawSolName[CGNS_MAX_STR_LEN];
-    GridLocation_t location;
+    CGNS_ENUMT( GridLocation_t ) location;
     cgnsErr = cg_sol_info(fileIndex, baseIndex, zoneIndex, zoneSolIndex,
                           rawSolName, &location);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
@@ -413,12 +413,12 @@ namespace {
 
     // get zone dimension and type
     int dim;
-    ZoneType_t zoneType;
+    CGNS_ENUMT( ZoneType_t ) zoneType;
     cgnsErr = cg_cell_dim(fileIndex, baseIndex, &dim);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
     cgnsErr = cg_zone_type(fileIndex, baseIndex, zoneIndex, &zoneType);
     if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
-    const bool isStructured = (zoneType == Structured);
+    const bool isStructured = (zoneType == CGNS_ENUMV( Structured ));
 
     // get total number of vertices and elements in zone
     char zoneName[CGNS_MAX_STR_LEN];
@@ -442,7 +442,7 @@ namespace {
     // read point range if it exists, otherwise use all entities
     // (vertices/elements) in zone
     std::vector<cgsize_t> solEntSet;
-    PointSetType_t ptSetType;
+    CGNS_ENUMT( PointSetType_t ) ptSetType;
     cgsize_t ptSetSize;
     cgsize_t solReadRange[6];
     cgnsErr = cg_sol_ptset_info(fileIndex, baseIndex, zoneIndex, zoneSolIndex,
@@ -494,7 +494,7 @@ namespace {
     // get field data
     for(int iField = 1; iField <= nbField; iField++) {
       // field name
-      DataType_t cgnsDataType;
+      CGNS_ENUMT( DataType_t ) cgnsDataType;
       char rawFieldName[CGNS_MAX_STR_LEN];
       cgnsErr = cg_field_info(fileIndex, baseIndex, zoneIndex, zoneSolIndex,
                               iField, &cgnsDataType, rawFieldName);
@@ -504,7 +504,7 @@ namespace {
       // read field data
       std::vector<double> data(dataSize);
       cgnsErr = cg_field_read(
-        fileIndex, baseIndex, zoneIndex, zoneSolIndex, rawFieldName, RealDouble,
+        fileIndex, baseIndex, zoneIndex, zoneSolIndex, rawFieldName, CGNS_ENUMV( RealDouble ),
         solReadRangeMin, solReadRangeMax, static_cast<void *>(data.data()));
       if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
 
diff --git a/Post/PViewIO_CGNS.cpp b/Post/PViewIO_CGNS.cpp
index b4ed767..d83048b 100644
--- a/Post/PViewIO_CGNS.cpp
+++ b/Post/PViewIO_CGNS.cpp
@@ -33,15 +33,15 @@ namespace {
       for(int iZoneSol = 1; iZoneSol <= nbZoneSol; iZoneSol++) {
         // get FlowSolution info
         char rawSolName[CGNS_MAX_STR_LEN];
-        GridLocation_t location;
+        CGNS_ENUMT( GridLocation_t ) location;
         cgnsErr = cg_sol_info(fileIndex, baseIndex, iZone, iZoneSol, rawSolName,
                               &location);
         if(cgnsErr != CG_OK) return cgnsError(__FILE__, __LINE__, fileIndex);
         const std::string solName(rawSolName);
         PViewDataGModel::DataType type;
-        if(location == CellCenter)
+        if(location == CGNS_ENUMV( CellCenter ))
           type = PViewDataGModel::ElementData;
-        else if(location == Vertex) {
+        else if(location == CGNS_ENUMV(Vertex)) {
           if(nbZone > 1) {
             Msg::Warning(
               "Multi-zone node-based solutions not supported in CGNS "
@@ -71,7 +71,7 @@ namespace {
 
         // get names of fields
         for(int iField = 1; iField <= nbField; iField++) {
-          DataType_t dataType;
+          CGNS_ENUMT( DataType_t ) dataType;
           char rawFieldName[CGNS_MAX_STR_LEN];
           cgnsErr = cg_field_info(fileIndex, baseIndex, iZone, iZoneSol, iField,
                                   &dataType, rawFieldName);
-- 
2.29.0

